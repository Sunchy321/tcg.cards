import { Directory, ExportedDeclarations, SourceFile, SyntaxKind, VariableDeclarationKind } from 'ts-morph';

import { Model, createModel } from './model';
import { applyComputed, parseComputed } from './computed';
import { modelIntoSchema, printSchema } from './schema';

import { addAutoGeneratedComment } from './util';

import { serverSrc } from './server';

export class Game {
    #name:      string;
    #interface: Directory;
    #model:     Directory;

    constructor(source: Directory, model: Directory) {
        this.#name = source.getBaseName();
        this.#interface = source;
        this.#model = model;
    }

    getInterface(name: string): SourceFile {
        return this.#interface.getSourceFileOrThrow(name);
    }

    tryGetInterface(name: string): SourceFile | undefined {
        return this.#interface.getSourceFile(name);
    }

    getModel(name: string): SourceFile {
        return this.#model.getSourceFileOrThrow(name);
    }

    tryGetModel(name: string): SourceFile | undefined {
        return this.#model.getSourceFile(name);
    }

    hasDeclaration(source: SourceFile, name: string): boolean {
        return source.getExportedDeclarations().get(name) != null;
    }

    getDeclaration(source: SourceFile, name: string): ExportedDeclarations {
        const result = source.getExportedDeclarations().get(name)?.[0];

        if (result == null) {
            throw new Error(`exported declaration ${name} not found in ${source.getBaseName()}`);
        }

        return result;
    }

    tryGetDeclaration(source: SourceFile | undefined, name: string): ExportedDeclarations | undefined {
        return source?.getExportedDeclarations()?.get(name)?.[0];
    }

    createInterfaceModel(filename: string, typename: string): Model {
        const typeDecl = this.getDeclaration(this.getInterface(filename), typename);

        return createModel(typeDecl as any);
    }

    createComputedModel(filename: string, typename: string): Model {
        const typeDecl = this.getDeclaration(this.getModel(filename), typename);

        return createModel(typeDecl as any);
    }

    generate(): void {
        this.generateDatabase();
    }

    generateDatabase(): void {
        this.generateDatabaseConn().saveSync();
        this.generateCardDatabase().saveSync();

        if (this.tryGetInterface('print.ts') != null) {
            this.generatePrintDatabase().saveSync();
        }

        if (this.tryGetInterface('format.ts') != null) {
            this.generateFormatDatabase().saveSync();
            this.generateFormatAnnouncementDatabase().saveSync();
            this.generateFormatChangeDatabase().saveSync();
        }
    }

    generateDatabaseConn(): SourceFile {
        const dbName = `${this.#name}/db/db.ts`;

        const source = serverSrc.addSourceFileAtPathIfExists(dbName) ?? serverSrc.createSourceFile(dbName);

        source.removeText();

        addAutoGeneratedComment(source);

        source.addImportDeclaration({
            moduleSpecifier: '@/db',
            namedImports:    [{ name: 'connect' }],
        });

        source.addVariableStatement({
            leadingTrivia:   writer => writer.newLine(),
            declarationKind: VariableDeclarationKind.Const,
            declarations:    [{
                name:        'conn',
                initializer: `connect('${this.#name}')`,
            }],
        });

        source.addExportAssignment({
            leadingTrivia:  writer => writer.newLine(),
            isExportEquals: false,
            expression:     'conn',
        });

        return source;
    }

    generateCardDatabase(): SourceFile {
        const name = `${this.#name}/db/card.ts`;

        const cardModel = this.createInterfaceModel('card.ts', 'Card');

        const cardDatabase = this.getDeclaration(this.getModel('card.ts'), 'ICardDatabase');

        if (!cardDatabase.isKind(SyntaxKind.TypeAliasDeclaration)) {
            throw new Error('Wrong card database type');
        }

        const hasOnSave = this.tryGetDeclaration(this.getModel('card.ts'), 'onSave') != null;

        let cardDatabaseModel = createModel(cardDatabase as any);

        const computedList = parseComputed(cardDatabase);

        cardDatabaseModel = applyComputed(cardDatabaseModel, computedList ?? []);

        if (cardModel.kind !== 'object' || cardDatabaseModel.kind !== 'object') {
            throw new Error('Wrong card database model type');
        }

        cardDatabaseModel.keyValues.sort((a, b) => {
            const aIndex = cardModel.keyValues.findIndex(v => v.key === a.key);
            const bIndex = cardModel.keyValues.findIndex(v => v.key === b.key);

            if (aIndex === -1) {
                if (bIndex === -1) {
                    return 0;
                } else {
                    return 1;
                }
            } else {
                if (bIndex === -1) {
                    return -1;
                } else {
                    return aIndex - bIndex;
                }
            }
        });

        for (const [i, kv] of cardDatabaseModel.keyValues.entries()) {
            const cardItem = cardModel.keyValues.find(v => v.key === kv.key);

            if (cardItem == null) {
                if (i > 0) {
                    const lastItem = cardDatabaseModel.keyValues[i - 1];

                    const lastCardItem = cardModel.keyValues.find(v => v.key === lastItem.key);

                    if (lastCardItem != null) {
                        lastItem.hasTrailingNewline = true;
                    }
                }
            } else {
                kv.hasTrailingNewline = cardItem.hasTrailingNewline;
            }

            if (kv.key === '__updations') {
                kv.hasTrailingNewline = true;
            }
        }

        const source = serverSrc.addSourceFileAtPathIfExists(name) ?? serverSrc.createSourceFile(name);

        source.removeText();

        source.addStatements('/** AUTO GENERATED, DO NOT CHANGE **/');

        source.addImportDeclaration({
            moduleSpecifier: 'mongoose',
            namedImports:    [{ name: 'Model' }, { name: 'Schema' }],
        });

        source.addImportDeclaration({
            leadingTrivia:   writer => writer.newLine(),
            moduleSpecifier: './db',
            defaultImport:   'conn',
        });

        const imports = [
            'ICardDatabase',
            'toJSON',
        ];

        for (const c of computedList ?? []) {
            if (!imports.includes(c.watcher)) {
                imports.push(c.watcher);
            }
        }

        if (hasOnSave) {
            imports.push('onSave');
        }

        source.addImportDeclaration({
            leadingTrivia:   writer => writer.newLine(),
            moduleSpecifier: `@common/model/${this.#name}/card`,
            namedImports:    imports.map(name => ({ name })),
        });

        source.addVariableStatement({
            leadingTrivia:   '// eslint-disable-next-line @typescript-eslint/no-empty-object-type',
            declarationKind: VariableDeclarationKind.Const,
            declarations:    [{
                name:        'CardSchema',
                initializer: writer => {
                    writer.write(
                        'new Schema<ICardDatabase, Model<ICardDatabase>, {}, {}, {}, {}, \'$type\'>('
                        + printSchema(modelIntoSchema(cardDatabaseModel))
                        + `, {\n typeKey: '$type',\n toJSON: { transform: toJSON } \n})`,
                    );
                },
            }],
        });

        if (hasOnSave) {
            source.addStatements(writer => {
                writer.newLine();
                writer.writeLine('CardSchema.pre(\'save\', async function() {');
                writer.writeLine('    onSave.call(this);');
                writer.writeLine('});');
                writer.newLine();
            });
        }

        source.addVariableStatement({
            leadingTrivia:   writer => writer.newLine(),
            declarationKind: VariableDeclarationKind.Const,
            declarations:    [{
                name:        'Card',
                initializer: 'conn.model(\'card\', CardSchema)',
            }],
        });

        source.addExportAssignment({
            leadingTrivia:  writer => writer.newLine(),
            isExportEquals: false,
            expression:     'Card',
        });

        return source;
    }

    generatePrintDatabase(): SourceFile {
        const name = `${this.#name}/db/print.ts`;

        const printModel = this.createInterfaceModel('print.ts', 'Print');

        const printDatabase = this.getDeclaration(this.getModel('print.ts'), 'IPrintDatabase');

        if (!printDatabase.isKind(SyntaxKind.TypeAliasDeclaration)) {
            throw new Error('Wrong print database type');
        }

        let printDatabaseModel = createModel(printDatabase as any);

        const computedList = parseComputed(printDatabase);

        printDatabaseModel = applyComputed(printDatabaseModel, computedList ?? []);

        if (printModel.kind !== 'object' || printDatabaseModel.kind !== 'object') {
            throw new Error('Wrong print database model type');
        }

        printDatabaseModel.keyValues.sort((a, b) => {
            const aIndex = printModel.keyValues.findIndex(v => v.key === a.key);
            const bIndex = printModel.keyValues.findIndex(v => v.key === b.key);

            if (aIndex === -1) {
                if (bIndex === -1) {
                    return 0;
                } else {
                    return 1;
                }
            } else {
                if (bIndex === -1) {
                    return -1;
                } else {
                    return aIndex - bIndex;
                }
            }
        });

        for (const [i, kv] of printDatabaseModel.keyValues.entries()) {
            const cardItem = printModel.keyValues.find(v => v.key === kv.key);

            if (cardItem == null) {
                if (i > 0) {
                    const lastItem = printDatabaseModel.keyValues[i - 1];

                    const lastCardItem = printModel.keyValues.find(v => v.key === lastItem.key);

                    if (lastCardItem != null) {
                        lastItem.hasTrailingNewline = true;
                    }
                }
            } else {
                kv.hasTrailingNewline = cardItem.hasTrailingNewline;
            }

            if (kv.key === '__updations') {
                kv.hasTrailingNewline = true;
            }
        }

        const source = serverSrc.addSourceFileAtPathIfExists(name) ?? serverSrc.createSourceFile(name);

        source.removeText();

        source.addStatements('/** AUTO GENERATED, DO NOT CHANGE **/');

        source.addImportDeclaration({
            moduleSpecifier: 'mongoose',
            namedImports:    [{ name: 'Model' }, { name: 'Schema' }],
        });

        source.addImportDeclaration({
            leadingTrivia:   writer => writer.newLine(),
            moduleSpecifier: './db',
            defaultImport:   'conn',
        });

        source.addImportDeclaration({
            leadingTrivia:   writer => writer.newLine(),
            moduleSpecifier: `@common/model/${this.#name}/print`,
            namedImports:    [
                { name: 'IPrintDatabase' },
                { name: 'toJSON' },
                ...(computedList ?? []).map(c => ({ name: c.watcher })),
            ],
        });

        source.addVariableStatement({
            leadingTrivia:   '// eslint-disable-next-line @typescript-eslint/no-empty-object-type',
            declarationKind: VariableDeclarationKind.Const,
            declarations:    [{
                name:        'PrintSchema',
                initializer: writer => {
                    writer.write(
                        'new Schema<IPrintDatabase, Model<IPrintDatabase>, {}, {}, {}, {}, \'$type\'>('
                        + printSchema(modelIntoSchema(printDatabaseModel))
                        + `, {\n typeKey: '$type',\n toJSON: { transform: toJSON } \n})`,
                    );
                },
            }],
        });

        source.addVariableStatement({
            leadingTrivia:   writer => writer.newLine(),
            declarationKind: VariableDeclarationKind.Const,
            declarations:    [{
                name:        'Print',
                initializer: 'conn.model(\'print\', PrintSchema)',
            }],
        });

        source.addExportAssignment({
            leadingTrivia:  writer => writer.newLine(),
            isExportEquals: false,
            expression:     'Print',
        });

        return source;
    }

    generateFormatDatabase(): SourceFile {
        const name = `${this.#name}/db/format.ts`;

        const model = this.createInterfaceModel('format.ts', 'Format');

        const source = serverSrc.addSourceFileAtPathIfExists(name) ?? serverSrc.createSourceFile(name);

        source.removeText();

        source.addStatements('/** AUTO GENERATED, DO NOT CHANGE **/');

        source.addImportDeclaration({
            moduleSpecifier: 'mongoose',
            namedImports:    [{ name: 'Model' }, { name: 'Schema' }],
        });

        source.addImportDeclaration({
            leadingTrivia:   writer => writer.newLine(),
            moduleSpecifier: './db',
            defaultImport:   'conn',
        });

        source.addImportDeclaration({
            leadingTrivia:   writer => writer.newLine(),
            moduleSpecifier: `@interface/${this.#name}/format`,
            namedImports:    [
                { name: 'Format', alias: 'IFormat' },
            ],
        });

        source.addImportDeclaration({
            leadingTrivia:   writer => writer.newLine(),
            moduleSpecifier: `@common/model/updation`,
            namedImports:    [
                { name: 'defaultToJSON' },
            ],
        });

        source.addVariableStatement({
            leadingTrivia:   '// eslint-disable-next-line @typescript-eslint/no-empty-object-type',
            declarationKind: VariableDeclarationKind.Const,
            declarations:    [{
                name:        'FormatSchema',
                initializer: writer => {
                    writer.write(
                        'new Schema<IFormat, Model<IFormat>, {}, {}, {}, {}, \'$type\'>('
                        + printSchema(modelIntoSchema(model))
                        + `, {\n typeKey: '$type',\n toJSON: { transform: defaultToJSON } \n})`,
                    );
                },
            }],
        });

        source.addVariableStatement({
            leadingTrivia:   writer => writer.newLine(),
            declarationKind: VariableDeclarationKind.Const,
            declarations:    [{
                name:        'Format',
                initializer: 'conn.model(\'format\', FormatSchema)',
            }],
        });

        source.addExportAssignment({
            leadingTrivia:  writer => writer.newLine(),
            isExportEquals: false,
            expression:     'Format',
        });

        return source;
    }

    generateFormatAnnouncementDatabase(): SourceFile {
        const name = `${this.#name}/db/format-announcement.ts`;

        const model = this.createInterfaceModel('format-change.ts', 'FormatAnnouncement');

        const source = serverSrc.addSourceFileAtPathIfExists(name) ?? serverSrc.createSourceFile(name);

        source.removeText();

        source.addStatements('/** AUTO GENERATED, DO NOT CHANGE **/');

        source.addImportDeclaration({
            moduleSpecifier: 'mongoose',
            namedImports:    [{ name: 'Model' }, { name: 'Schema' }],
        });

        source.addImportDeclaration({
            leadingTrivia:   writer => writer.newLine(),
            moduleSpecifier: './db',
            defaultImport:   'conn',
        });

        source.addImportDeclaration({
            leadingTrivia:   writer => writer.newLine(),
            moduleSpecifier: `@interface/${this.#name}/format-change`,
            namedImports:    [
                { name: 'FormatAnnouncement', alias: 'IFormatAnnouncement' },
            ],
        });

        source.addImportDeclaration({
            leadingTrivia:   writer => writer.newLine(),
            moduleSpecifier: `@common/model/updation`,
            namedImports:    [
                { name: 'defaultToJSON' },
            ],
        });

        source.addVariableStatement({
            leadingTrivia:   '// eslint-disable-next-line @typescript-eslint/no-empty-object-type',
            declarationKind: VariableDeclarationKind.Const,
            declarations:    [{
                name:        'FormatAnnouncementSchema',
                initializer: writer => {
                    writer.write(
                        'new Schema<IFormatAnnouncement, Model<IFormatAnnouncement>, {}, {}, {}, {}, \'$type\'>('
                        + printSchema(modelIntoSchema(model))
                        + `, {\n typeKey: '$type',\n toJSON: { transform: defaultToJSON } \n})`,
                    );
                },
            }],
        });

        source.addVariableStatement({
            leadingTrivia:   writer => writer.newLine(),
            declarationKind: VariableDeclarationKind.Const,
            declarations:    [{
                name:        'FormatAnnouncement',
                initializer: 'conn.model(\'format_announcement\', FormatAnnouncementSchema)',
            }],
        });

        source.addExportAssignment({
            leadingTrivia:  writer => writer.newLine(),
            isExportEquals: false,
            expression:     'FormatAnnouncement',
        });

        return source;
    }

    generateFormatChangeDatabase(): SourceFile {
        const name = `${this.#name}/db/format-change.ts`;

        const model = this.createInterfaceModel('format-change.ts', 'FormatChange');

        const source = serverSrc.addSourceFileAtPathIfExists(name) ?? serverSrc.createSourceFile(name);

        source.removeText();

        source.addStatements('/** AUTO GENERATED, DO NOT CHANGE **/');

        source.addImportDeclaration({
            moduleSpecifier: 'mongoose',
            namedImports:    [{ name: 'Model' }, { name: 'Schema' }],
        });

        source.addImportDeclaration({
            leadingTrivia:   writer => writer.newLine(),
            moduleSpecifier: './db',
            defaultImport:   'conn',
        });

        source.addImportDeclaration({
            leadingTrivia:   writer => writer.newLine(),
            moduleSpecifier: `@interface/${this.#name}/format-change`,
            namedImports:    [
                { name: 'FormatChange', alias: 'IFormatChange' },
            ],
        });

        source.addImportDeclaration({
            leadingTrivia:   writer => writer.newLine(),
            moduleSpecifier: `@common/model/updation`,
            namedImports:    [
                { name: 'defaultToJSON' },
            ],
        });

        source.addVariableStatement({
            leadingTrivia:   '// eslint-disable-next-line @typescript-eslint/no-empty-object-type',
            declarationKind: VariableDeclarationKind.Const,
            declarations:    [{
                name:        'FormatChangeSchema',
                initializer: writer => {
                    writer.write(
                        'new Schema<IFormatChange, Model<IFormatChange>, {}, {}, {}, {}, \'$type\'>('
                        + printSchema(modelIntoSchema(model))
                        + `, {\n typeKey: '$type',\n toJSON: { transform: defaultToJSON } \n})`,
                    );
                },
            }],
        });

        source.addVariableStatement({
            leadingTrivia:   writer => writer.newLine(),
            declarationKind: VariableDeclarationKind.Const,
            declarations:    [{
                name:        'FormatChange',
                initializer: 'conn.model(\'format_change\', FormatChangeSchema)',
            }],
        });

        source.addExportAssignment({
            leadingTrivia:  writer => writer.newLine(),
            isExportEquals: false,
            expression:     'FormatChange',
        });

        return source;
    }
}
